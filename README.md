#### Все что нужно для работы с DOM

### ПОИСК 

#### Новые методы
`elem.querySelector(selector)`  Используется когда мы заведомо знаем, что подходящий элемент только `один`.
  - Возвращает не все, а только первый элемент, соответствующий CSS-селектору selector. Иначе говоря – ищется только первое совпадение, после чего поиск прекращается.
  - Если ничего не найдено, вернет null.

`elem.querySelectorAll(selector)`  Используется когда мы заведомо знаем, что подходящих элементов `более одного`.
  - Возвращает псевдомассив всех элементов внутри elem, удовлетворяющих CSS-селектору selector.
  - Псевдо-классы в selector, такие как :hover и :active, также поддерживаются.
  - Если ничего не найдено вернет пустой массив.

#### Устаревшие методы
`document.getElementById(id)`	Выбирает дом узел по идентификатору id. Возвращает ссылку на найденый DOM-узел или null если ничего не найдено.

`elem.getElementsByTagName(tag)`	Ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка

`elem.getElementsByClassName(cls)`	Возвращает коллекцию элементов с классом cls. Находит элемент и в том случае, если у него несколько классов, а искомый – один из них.

### АТРИБУТЫ

#### Работа с атрибутами тегов HTML

`elem.hasAttribute(name)`	Проверяет наличие аттрибута, `ВОЗВРАЩАЕТ TRUE/FALSE`

`elem.getAttribute(name)`	ПОЛУЧАЕТ значение атрибута и возвращает его

`elem.setAttribute(name, value)`	УСТАНАВЛИВАЕТ атрибут

`elem.removeAttribute(name)`	УДАЛЯЕТ атрибут

`elem.attributes`	свойство, возвращает КОЛЛЕКЦИЮ всех атрибутов элемента

### DOM-СВОЙСТВА

`.hidden` Работает так же, как style = "display: none". Возможные значния true или false.

`.value` Содержит контент input, select, textarea.

`.href`	 Содержимое атрибута href ссылки.

`.alt`	 Альтернативный текст изображения.  

### КЛАССЫ

#### Методы для работы с классами элемента. Оперирует значениями атрибута class="..." тегов HTML

`elem.classList.contains(cls)`	проверяет есть ли такой класс в значение атрибута class="" элемента `ВОЗВРАЩАЕТ TRUE/FALSE` 

`elem.classList.add(cls)`	добавляет класс cls в значение атрибута class="" элемента 

`elem.classList.remove(cls)`	удаляет класс cls в значение атрибута class="" элемента 

`elem.classList.toggle(cls)`	если класса cls нет, добавляет его, если есть - удаляет.

### DOM-УЗЛЫ

#### Создание. 
`.createElement("тег")` создаст HTML тег указанный аргументом

#### Вставка. 
> ##### Сперва указываем РОДИТЕЛЯ вставки затем КУДА вставляем затем КАКОЙ елемент 

##### 1-родитель 2-место вставки  3-созданный елемент

`node.append(nodes)`	добавляет nodes в КОНЕЦ node

`node.prepend(nodes)`	добавляет nodes в НАЧАЛО node

`node.after(nodes)`	добавляет nodes ПОСЛЕ узла node

`node.before(nodes)`	добавляет nodes ПЕРЕД узлом node

`node.replaceWith(nodes)`	добавляет nodes ВМЕСТО node

#### Удаление.

`elem.remove()` - удаляет elem из DOM

`elem.remove("elem")` - удаляет elem который указан аргументом из elem-который указан вначале. Например если нужно удалить дочерний елемент , который входит в состав родительского елемента  

### ПОЛУЧАЕМ КОНТЕНТ

#### innerHTML   

`elem.innerHTML`  позволяет получить `содержимое элемента в виде строки`. Оно доступно как для чтения так и для записи. Это значит используя innerHTML мы можем добавить что-то внутрь элемента. `для создания новых DOM-узлов.`
#### textContent
`elem.textContent`    содержит `только текст внутри элемента, за вычетом всех тегов`. textContent доступен для записи, при чем вне зависимости что будет передано в textContent, данные `всегда будут записаны как текст`.

### HTM5 DATA-АТРИБУТЫ

##### В HTML5 можно создавать произвольный атрибут и получать значения этого атрибута в JavaScript. 
###### Прием использования произвольного атрибута заключается в следующем:

- Создается атрибут общий для группы input: к корню слова date через дефис дописывают произвольный суффикс (например - "data-color").

- Вновь созданному атрибуту присваивается значение, связанное с данным input (например - "red", "blue" и т.д.)

- В JavaScript обращаемся к псевдомассиву элементов input для получения значения input - elem.value

- В JavaScript обращаемся к псевдомассиву элементов input для получения значения атрибута input - elem.dataset.color 

### НАВИГАЦИЯ ПО УЗЛАМ.

 - `elem.parentNode`	Выберет `РОДИТЕЛЯ` elem

##### Псевдомассиы
 - `elem.children`	Псевдо-массив хранит только `ДОЧЕРНИЕ УЗЛЫ-ЭЛЕМЕНТЫ`, то есть `ТЕГИ`

 - `elem.childNodes`	Псевдо-массив хранит `ВСЕ ДОЧЕРНИЕ` элементы, то есть `ТЕГИ` и `ТЕКСТОВЫЕ`

##### Первый внутри родителя
 - `elem.firstElementChild`	Выберет `ПЕРВЫЙ ДОЧЕРНИЙ УЗЕЛ-ЭЛЕМЕНТ` внутри elem, то есть `ТЕГ`

 - `elem.firstChild`	Выберет `ПЕРВЫЙ ДОЧЕРНИЙ элемент`  внутри elem, включая `ТЕКСТОВЫЕ` узлы.


##### Последний внутри родителя
 - `elem.lastElementChild`	Выберет `ПОСЛЕДНИЙ ДОЧЕРНИЙ УЗЕЛ-ЭЛЕМЕНТ` внутри elem. то есть `ТЕГ`

 - `elem.lastChild	` Выберет `ПОСЛЕДНИЙ ДОЧЕРНИЙ элемент`  внутри elem, включая `ТЕКСТОВЫЕ` узлы.

##### Слева от соседа
 - `elem.previousElementSibling`	Выберет `УЗЕЛ-ЭЛЕМЕНТ` "слева" от elem (его предыдущего соседа) 

 - `elem.previousSibling`	Выберет `элемент` "слева" от elem (его предыдущего соседа)


##### Справа от соседа
 - `elem.nextElementSibling`	Выберет `УЗЕЛ-ЭЛЕМЕНТ` "справа" от elem (его предыдущего соседа)

 - `elem.nextSibling`	Выберет `элемент` "справа" от elem (его следующего соседа)

## СОБЫТИЯ

#### addEventListener
`addEventListener()`  добавить слушателя события. 

##### Принимает три параметра

- `event`	  имя/тип события, например click, передается как строка
- `handler`	ссылка на функцию, которую надо поставить обработчиком 
- `phase`	  Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен.

###### Хорошей практикой считается когда функцию обработчик выносим за пределы. А в качестве аргумента при вызове слушателя события передаем ссылку на нее. 
###### Также не стоит использовать аргументом слушателя АНОНИМНУЮ функцию `() => { }` так как на нее не получится получить ссылку. 

#### removeEventListener
`removeEventListener`  Удаление слушателя события осуществляется вызовом removeEventListener. Аргументы те же что у addEventListener

###### При удалении слушателя , вторым аргументом, должна быть ТАЖЕ функция как и при добавлении слушателя. 


##### Детали произошедшего браузер записывает в «объект события» event, который передаётся первым аргументом в обработчик. 
##### У этого объекта много методов, таких как .target, .currentTarget , .nodeName, .clientX и  .clientY и др. 


#### Всплытие

##### При клике или ином другом событии, происходит следующее: 

- capturing phase - событие начинается на window и тонет до самого глубокого целевого элемента

- target phase - событие дошло до самого глубокого целевого элемента

- bubbling phase - событие всплывает от самого глубокого целевого элемента до window

##### После того  как событие дошло до цели , в объект `event` запишется все информация о целевом елементе, которую в дальнейшем мы можем использовать. После чего наступает фаза всплытия и "пакет с информацией" летит наверх , где мы можем его перехватить. Для этого используется делегирование. 

##### Фазу всплытия можно контролировать

`event.stopPropagation()` останавливает дальнейшее всплытие. тоесть событие отработает на текущей цели и дальше не всплывет

#### Делегирование

##### Назначаем слушателя событий родителю, который будет отлавливать события которые будут происходить с дочерними елементами. Это позволяет не писать событие для каждого елемента а ограничится одним. Далее через event.target можно узнать на каком елементе произошло событие. С помощтю event.nodeName , который возвращает имя тега с которым произошло событие, узнаем тег и можем проводить разные проверки и условия.  

`event.target`  получаем ССЫЛКУ на елемент на котором произошло событие

`event.nodeName` возвращает ИМЯ ТЕГА в виде строки в верхнем регистре - 'IMG', 'DIV' и т.п. С помощью этого метода отсеиваем ненужные события. Например нам нужно получить значение атрибута тега <img>, на родителя повесили слушателя событий. При таком раскладе мы будем получать события для всех елементов внутри. С помощью метода можем сделать проверку `if (event.target.nodeName !== 'IMG') return` если целевой елемент НЕ <img> , то выходим из функции. 

#### Действия браузера по умолчанию

##### Браузер имеет встроенные действия при ряде событий – переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.

##### Например:

- Клик по ссылке инициирует переход на новый URL.
- Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.
- Двойной клик на тексте – инициирует его выделение.
- Основной способ это воспользоваться объектом события. 

##### Для отмены действия браузера существует стандартный метод 

`event.preventDefault()` отменяет действия браузера по умолчанию

#### Загрузка документа

##### процесс загрузки HTML-документа, состоит из трёх стадий

- DOMContentLoaded – браузер полностью загрузил HTML и построил DOM-дерево.
- load – браузер загрузил все ресурсы.
- beforeunload/unload – уход со страницы.

##### Мы будем вешать слушателей когда браузер построил DOM дерево

`document.addEventListener("DOMContentLoaded", ()=> { тут вешаем все свои слушатели})` 
- слушатели помещаем внутрь 
- все функции которые будут описывать нужные нам дейсвтвия помещаем вне

## АСИНХРОННОСТЬ

#### setTimeout и clearTimeout

`setTimeout( () => {CODE}, 2000);` принимает 2 аргумента
- callback-функцию которая будет вызвана по истечении времени
- время через которое сработает функция
Возвращает цифровой идентификатор созданного таймера, это необходимо для возможность его удаления.
 
`const timerId = setTimeout(callback, delay);` в переменную будет записан ID

##### Если нужно отменить вызов функции внутри таймаута, используется функция `clearTimeout(id)` , которая получает идентификатор (id) таймера и очищает (удаляет) его.
 
`clearTimeout(timerId);` удалит таймер timerId

#### setInterval и clearInterval

###### Интервалы - это более простой способ повторения кода снова и снова, с установленным промежутком времени повторений.
###### Функция `setInterval` имеет синтаксис, аналогичный `setTimeout`.

###### B отличие от `setTimeout`, она запускает выполнение функции не один раз, а регулярно повторяет её через указанный интервал времени (delay).
###### Остановить исполнение можно вызовом `clearInterval(id)`.